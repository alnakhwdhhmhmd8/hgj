import asyncio
import os
import time
import requests
import datetime
import random
import os
import time
from asyncio import sleep
from pyrogram import Client, filters
from pyrogram import enums, filters
from VeGaXMusic import app
from pytz import timezone
import datetime
from pytz import timezone
from pyrogram import enums
import aiohttp
import datetime
from pytz import timezone
from pyrogram import filters
from pyrogram import Client
from typing import Union
from random import choice
from config import OWNER_ID
from config import BANNED_USERS
from config import BANNED_USERS, OWNER_ID
from VeGaXMusic.core.call import KIM
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from VeGaXMusic import (Apple, Resso, SoundCloud, Spotify, Telegram, YouTube, app)
from VeGaXMusic import app
from telegraph import upload_file
from asyncio import gather
from pyrogram.errors import FloodWait
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup

import asyncio
from PIL import Image, ImageDraw, ImageFont
from pyrogram import filters, Client, enums
from pyrogram.types import *
from typing import Union, Optional
from VeGaXMusic import app as Hiroko 

from PIL import (Image, ImageDraw, ImageEnhance, ImageFilter,
                 ImageFont, ImageOps)
import asyncio
import os
import random
import re
import textwrap
import aiofiles
import aiohttp
from PIL import Image, ImageDraw, ImageEnhance, ImageFilter, ImageFont, ImageOps
from youtubesearchpython.__future__ import VideosSearch
import numpy as np

from config import YOUTUBE_IMG_URL


import asyncio
import os
import time
import requests
import datetime
import random
import os
import time
from asyncio import sleep
from pyrogram import Client, filters
from pyrogram import enums, filters
from VeGaXMusic import app
from config import *
import config
from VeGaXMusic import  app
from config import OWNER_ID
from pytz import timezone
from pyrogram import enums
import aiohttp

import datetime
from pytz import timezone
from pyrogram import filters
from pyrogram import Client
from typing import Union
from random import choice
from config import OWNER_ID
from config import BANNED_USERS
from config import BANNED_USERS, OWNER_ID
from VeGaXMusic.core.call import KIM
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from VeGaXMusic import (Apple, Resso, SoundCloud, Spotify, Telegram, YouTube, app)
from VeGaXMusic import app
from telegraph import upload_file
from asyncio import gather
from pyrogram.errors import FloodWait
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup



from datetime import datetime
from pyrogram import Client, filters
from pyrogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup


import asyncio
from PIL import Image, ImageDraw, ImageFont
from pyrogram import filters, Client, enums
from pyrogram.types import *
from typing import Union, Optional
from VeGaXMusic import app as Hiroko 

# Function to get font and resize text



import requests
from PIL import Image
import os






import asyncio
import os
import random
import re
import textwrap
import aiofiles
import aiohttp
from PIL import Image, ImageDraw, ImageEnhance, ImageFilter, ImageFont, ImageOps
from youtubesearchpython.__future__ import VideosSearch
import numpy as np

from config import YOUTUBE_IMG_URL


import asyncio
import os
import time
import requests
import datetime
import random
import os
import time
from asyncio import sleep
from pyrogram import Client, filters
from pyrogram import enums, filters
from VeGaXMusic import app

from pytz import timezone
from pyrogram import enums
import aiohttp
import datetime
from pytz import timezone
from pyrogram import filters
from pyrogram import Client
from typing import Union
from random import choice
from config import OWNER_ID
from config import BANNED_USERS
from config import BANNED_USERS, OWNER_ID
from VeGaXMusic.core.call import KIM
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from VeGaXMusic import (Apple, Resso, SoundCloud, Spotify, Telegram, YouTube, app)
from VeGaXMusic import app
from telegraph import upload_file
from asyncio import gather
from pyrogram.errors import FloodWait
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup










# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚[ğ—©.ğ—˜.ğ—š.ğ—”]â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
#â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€ â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€
#â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ”€â”€â”€â”€
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚[ğ—©.ğ—˜.ğ—š.ğ—”]â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# Ì·ğ–¾ğ™™ğ™šğ™¥ğ™¡ğ™¤ğ™®ğ™šğ™™ ğ™¨ğ™ªğ™˜ğ™˜ğ™šğ™¨ğ™¨ğ™›ğ™ªğ™¡ğ™¡ğ™®
# (2024-2025) ğ™—ğ™®: @ğ™ğ™Šğ™‹ğ™‘ğ™€ğ™‚ğ˜¼
# ğ™‚ğ™§ğ™šğ™šğ™©ğ™ğ™£ğ™œğ™¨ ğ™›ğ™§ğ™¤ğ™¢ : ğ™‘ğ™šğ™‚ğ™–

   





import asyncio
from PIL import Image, ImageDraw, ImageFont
from pyrogram import filters, Client, enums
from pyrogram.types import *
from typing import Union, Optional
from VeGaXMusic import app as Hiroko 

# Function to get font and resize text



import requests
from PIL import Image
import os

import asyncio
import re
import time
import requests
import aiohttp
import time
import asyncio
from pyrogram import Client, filters
from pyrogram import filters
from datetime import datetime
from pyrogram import enums
from VeGaXMusic.misc import SUDOERS
from config import OWNER_ID
from config import BANNED_USERS
from config import BANNED_USERS, OWNER_ID
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import CallbackQuery, InputMediaPhoto, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.enums import ChatType, ChatMemberStatus
from pyrogram.enums import ChatMemberStatus, ParseMode
from VeGaXMusic import app
from pyrogram.enums import ChatMembersFilter
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import ChatPermissions, ChatPrivileges
from config import *
from pyrogram.enums import ChatMembersFilter
from telegraph import upload_file
from asyncio import gather
from pyrogram.enums import ChatMembersFilter
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import ChatPermissions, ChatPrivileges
from config import *
from pyrogram.enums import ChatMembersFilter
import asyncio

from pyrogram.enums import ParseMode

from VeGaXMusic import app
from VeGaXMusic.utils.database import is_on_off
from config import LOG_GROUP_ID


from pyrogram import filters
from pyrogram import Client
from VeGaXMusic.core.call import KIM
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from VeGaXMusic import (Apple, Resso, SoundCloud, Spotify, Telegram, YouTube, app)
from VeGaXMusic import app
from telegraph import upload_file
from asyncio import gather

import random
from VeGaXMusic.misc import SUDOERS
from pyrogram.types import (Message,InlineKeyboardButton,InlineKeyboardMarkup,CallbackQuery,ChatPrivileges)
from pyrogram import filters, Client
from VeGaXMusic import app
from config import *



def is_owner(_, __, message):

    return message.from_user.id == OWNER_ID

# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚


iddof = []


@app.on_message(filters.command(["Ù‚ÙÙ„ Ø§Ù„Ø§ÙŠØ¯ÙŠ", "ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø§ÙŠØ¯ÙŠ"], ""), group=509)
async def iddlock(client, message):
   get = await client.get_chat_member(message.chat.id, message.from_user.id)
   if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID or message.from_user.id == 7728230165:
      if message.chat.id in iddof:
        return await message.reply_text(" Ø§Ù„Ø§ÙŠØ¯ÙŠ Ù…Ø¹Ø·Ù„ Ù…Ù† Ù‚Ø¨Ù„")
      iddof.append(message.chat.id)
      return await message.reply_text(" ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø§ÙŠØ¯ÙŠ Ø¨Ù†Ø¬Ø§Ø­")
   else:
      return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command(["ÙØªØ­ Ø§Ù„Ø§ÙŠØ¯ÙŠ", "ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§ÙŠØ¯ÙŠ"], ""), group=678)
async def iddopen(client, message):
   get = await client.get_chat_member(message.chat.id, message.from_user.id)
   if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID or message.from_user.id == 7728230165:
      if not message.chat.id in iddof:
        return await message.reply_text("Ø§Ù„Ø§ÙŠØ¯ÙŠ Ù…ÙØ¹Ù„ Ù…Ù† Ù‚Ø¨Ù„ ")
      iddof.remove(message.chat.id)
      return await message.reply_text("ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§ÙŠØ¯ÙŠ Ø¨Ù†Ø¬Ø§Ø­")
   else:
      return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")



id = {}

@app.on_message(filters.command(["Ø§ÙŠØ¯ÙŠ","Ø§Ù„Ø§ÙŠØ¯ÙŠ","Ø§","id","/id","/ID","ID"], ""), group=99)
async def muid(client: Client, message):
    if message.chat.id in iddof:
        return await message.reply_text("Ø§Ù„Ø§ÙŠØ¯ÙŠ Ù…Ø¹Ø·Ù„ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø¯Ù…Ù†")
    try:
        user = await client.get_chat(message.from_user.id)
        user_id = user.id
        username = user.username  # Raw username (might be None)
        display_username = username or "ØºÙŠØ± Ù…ØªÙˆÙØ±" #  For display purposes
        first_name = user.first_name or "ØºÙŠØ± Ù…ØªÙˆÙØ±"
        bioo = user.bio or "ØºÙŠØ± Ù…ØªÙˆÙØ±"
        
        photo = user.photo.big_file_id if user.photo else None
        
        if user.id not in id:
            id[user.id] = []
        idd = len(id[user.id])
        
        # Build inline keyboard buttons conditionally
        buttons = []
        if username:  # Only add URL button if username exists
            buttons.append(
                [InlineKeyboardButton(first_name, url=f"https://t.me/{username}")]
            )
        buttons.append(
            [InlineKeyboardButton(f"{idd} â¤ï¸", callback_data=f"heart{user_id}")]
        )
        
        # Caption uses display_username (includes fallback text)
        caption = (
            f"<b><blockquote>â•­â—‰ášÉ´á´§á´á´‡ : {message.from_user.mention}\n"
            f"â•°â—‰ášá´œsá´‡ê› : @{display_username}\n"
            f"â•­â—‰ášÉªá´… : <code>{user_id}</code>\n"
            f"â•°â—‰ášÊ™Éªá´ : {bioo}\n"
            f"â•­â—‰ášá´„Êœá´§á´› : {message.chat.title}\n"
            f"â•°â—‰ášá´„Êœá´§á´› Éªá´… : <code>{message.chat.id}</code></b></blockquote>"
        )
        
        if photo:
            photo = await client.download_media(photo)
            await message.reply_photo(
                photo=photo,
                caption=caption,
                reply_markup=InlineKeyboardMarkup(buttons)
            )
        else:
            await message.reply_text(
                caption,
                reply_markup=InlineKeyboardMarkup(buttons))
    except Exception as e:
        print(f"An error occurred: {e}")


@app.on_callback_query(filters.regex("heart"), group=54787866)
async def heart(client, query: CallbackQuery):  
    callback_data = query.data.strip()  
    callback_request = callback_data.replace("heart", "")  
    username = int(callback_request)
    try:
        usr = await client.get_chat(username)
        heart_giver = query.from_user.mention or query.from_user.first_name
        if usr.id not in id:
            id[usr.id] = []
        if heart_giver not in id[usr.id]:
            id[usr.id].append(heart_giver)
            fan_count = len(id[usr.id])
            await client.send_message(usr.id, f"Ù‚Ø§Ù… {heart_giver} Ø¨ÙˆØ¶Ø¹ Ù‚Ù„Ø¨ Ù„Ùƒ ÙˆØ§ØµØ¨Ø­ Ø¹Ø¯Ø¯ Ø§Ù„ÙØ§Ù†Ø²Ø§Øª {fan_count}")
        else:
            id[usr.id].remove(heart_giver)
            fan_count = len(id[usr.id])
            await client.send_message(usr.id, f"Ù‚Ø§Ù… {heart_giver} Ø¨Ø§Ù„ØºØ§Ø¡ Ù‚Ù„Ø¨ Ù„Ùƒ ÙˆØ§ØµØ¨Ø­ Ø¹Ø¯Ø¯ Ø§Ù„ÙØ§Ù†Ø²Ø§Øª {fan_count}")
        
        idd = len(id[usr.id])
        await query.edit_message_text(
            f"<blockquote><b>â•­â—‰ášÉ´á´§á´á´‡ : {usr.first_name}\nâ•°â—‰ášá´œsá´‡ê› : @{usr.username}\nâ•­â—‰ášÉªá´… : <code>{usr.id}</code>\nâ•°â—‰ášÊ™Éªá´ : {usr.bio}\nâ•­â—‰ášá´„Êœá´§á´› : {query.message.chat.title}\nâ•°â—‰ášá´„Êœá´§á´› Éªá´… : <code>{query.message.chat.id}</code></b></blockquote>", 
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton(usr.first_name, url=f"https://t.me/{usr.username}")], [InlineKeyboardButton(f"{idd} â¤ï¸", callback_data=f"heart{usr.id}")]])
        )
    except Exception as e:
        print(f"An error occurred: {e}")
        

# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚[ğ—©.ğ—˜.ğ—š.ğ—”]â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚

@app.on_message(filters.command(["ÙÙ†Ø²Ø§ØªÙŠ", "Ø§Ù„Ù…Ø¹Ø¬Ø§Ø¨ÙŠÙ†"], ""), group=5847878)
async def get_mt_fans(client: Client, message):
    user_id = message.from_user.id
    fan_count = len(id.get(user_id, []))  # 
    fann_count = "79911"
    
    if user_id == 7728230165:
        return await message.reply_text(f"Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù„ÙˆØ¨ Ù„Ø¯ÙŠÙƒ: {fann_count} â¤ï¸")
    
    if fan_count == 0:
        await message.reply_text("Ù„ÙŠØ³ Ù‡Ù†Ø§Ùƒ Ù…Ø¹Ø¬Ø§Ø¨ÙŠÙ†")
    else:
        await message.reply_text(f"<blockquote>Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù„ÙˆØ¨ Ù„Ø¯ÙŠÙƒ: {fan_count} â¤ï¸</blockquote>")

# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚[ğ—©.ğ—˜.ğ—š.ğ—”]â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚


@app.on_message(filters.command(["ÙÙ†Ø²Ø§ØªÙ‡", "Ø§Ù„Ù…Ø¹Ø¬Ø§Ø¨ÙŠÙ†"], ""), group=5847878)
async def get_mt_fans(client: Client, message):
    user_id = message.reply_to_message.from_user.id
    fan_count = len(id.get(user_id, []))  # 
    fann_count = "79911"
    
    if user_id == 7728230165:
        return await message.reply_text(f"Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù„ÙˆØ¨ Ù„Ø¯ÙŠÙƒ: {fann_count} â¤ï¸")
    
    if fan_count == 0:
        await message.reply_text("Ù„ÙŠØ³ Ù‡Ù†Ø§Ùƒ Ù…Ø¹Ø¬Ø§Ø¨ÙŠÙ†")
    else:
        await message.reply_text(f"<blockquote>Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù„ÙˆØ¨ Ù„Ø¯ÙŠÙƒ: {fan_count} â¤ï¸</blockquote>")

# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚[ğ—©.ğ—˜.ğ—š.ğ—”]â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚


@app.on_message(filters.command(["Ø§Ù„Ø¬Ø±ÙˆØ¨","Ø¬Ø±ÙˆØ¨","Ø§Ù†Ø§ ÙÙŠÙ†","ÙƒØ±ÙˆØ¨","Ù…Ø¬Ù…ÙˆØ¹Ù‡","Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©","/group"], ""), group=666)
async def ginnj(client: Client, message: Message):
    chat_idd = message.chat.id
    chat_name = message.chat.title
    chat_username = f"@{message.chat.username}"
    if message.chat.photo:
        photo = await client.download_media(message.chat.photo.big_file_id)
        await message.reply_photo(photo=photo, caption=f"""<b><b><blockquote> Ëšâ€§SHEIKHË³+\n\nâ•®â—‰  Ø§Ø³Ù… Ø§Ù„Ø¬Ø±ÙˆØ¨ Â» {chat_name}\nâ”‚ášœâ—‰ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ø¬Ø±ÙˆØ¨ Â»<code>{chat_idd}</code>\nâ•¯â—‰  Ø±Ø§Ø¨Ø· Ø§Ù„Ø¬Ø±ÙˆØ¨ Â» {chat_username}</b></blockquote>""",     
    reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        chat_name, url=f"https://t.me/{message.chat.username}")
                ],
            ]
        ),
    )
    else:
        await message.reply_text(f"""<blockquote><b><b> Ëšâ€§SHEIKHË³+\n\nâ•®â—‰ Ø§Ø³Ù… Ø§Ù„Ø¬Ø±ÙˆØ¨ Â» {chat_name}\nâ”‚ášœâ—‰ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ø¬Ø±ÙˆØ¨ Â»  -<code>{chat_idd}</code>\nâ•¯â—‰ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¬Ø±ÙˆØ¨ Â» {chat_username}</b></blockquote>""", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton(chat_name, url=f"https://t.me/{message.chat.username}")],]))    
        

# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚


@app.on_message(filters.command(["ÙØ­Øµ Ø§Ù„Ø¬Ø±ÙˆØ¨"], ""), group=26777)
async def instatus(Client, message):
    start_time = time.perf_counter()
    user = await app.get_chat_member(message.chat.id, message.from_user.id)
    count = await app.get_chat_members_count(message.chat.id)
    get = await app.get_chat_member(message.chat.id, message.from_user.id)
    if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID or message.from_user.id == 7728230165:
        chat_idd = message.chat.id
        chat_name = message.chat.title
        chat_username = f"@{message.chat.username}"
        deleted_acc = 0
        premium_acc = 0
        banned = 0
        bot = 0
        uncached = 0
        async for ban in app.get_chat_members(message.chat.id, filter=enums.ChatMembersFilter.BANNED):
            banned += 1
        async for member in app.get_chat_members(message.chat.id):
            user = member.user
            if user.is_deleted:
                deleted_acc += 1
            elif user.is_bot:
                bot += 1
            elif user.is_premium:
                premium_acc += 1
            else:
                uncached += 1
        end_time = time.perf_counter()
        timelog = "{:.2f}".format(end_time - start_time)
        if message.chat.photo:
             photo = await app.download_media(message.chat.photo.big_file_id)
             
             await message.reply_photo(photo=photo,  caption=f"""<blockquote><b>Â»â­“É¢ê›á´á´œá´˜ âœ˜ ÉªÉ´êœ°á´ê›á´á´§á´›Éªá´É´â™ª</blockquote>

<blockquote>â•®â—‰   Ø§Ù„Ø§Ø³Ù… : {message.chat.title} 
â”‚ášœâ—‰  ÙŠÙˆØ²Ø± : @{message.chat.username}
â•¯â—‰   Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ :  {count} 

â•®â—‰   Ø§Ù„Ø¨ÙˆØªØ§Øª : {bot}
â”‚ášœâ—‰  Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø­Ø°ÙˆÙÙ‡ : {deleted_acc}
â”‚ášœâ—‰  Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø­Ø¸ÙˆØ±Ù‡ : {banned}
â•¯â—‰   Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…ÙˆØ«Ù‚Ø© : {premium_acc}</b></blockquote>""",
         reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        chat_name, url=f"https://t.me/{message.chat.username}")
                ],
            ]
        ),
    )
        else:
             await message.reply_text(f"""<blockquote><b>Â»â­“É¢ê›á´á´œá´˜ âœ˜ ÉªÉ´êœ°á´ê›á´á´§á´›Éªá´É´â™ª</blockquote>\nâ•®â—‰  Ø§Ù„Ø§Ø³Ù… : {message.chat.title}\nâ”‚ášœâ—‰ ÙŠÙˆØ²Ø± : @{message.chat.username}\nâ•¯â—‰  Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ :  {count} \nâ•®â—‰  Ø§Ù„Ø¨ÙˆØªØ§Øª: {bot}\nâ”‚ášœâ—‰  Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø­Ø°ÙˆÙÙ‡ : {deleted_acc}\nâ”‚ášœâ—‰  Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†: {banned}\nâ•¯â—‰  Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ø¨Ø±ÙŠÙ…ÙŠÙˆÙ…: {premium_acc}</b>""", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton(chat_name, url=f"https://t.me/{message.chat.username}")],]))    
    else:
        sent_message = await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
        await sleep(3)
        await sent_message.delete()






# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚



mgssof = []
@app.on_message(filters.command(["Ù‚ÙÙ„ ØµÙˆØ±ØªÙŠ", "ØªØ¹Ø·ÙŠÙ„ ØµÙˆØ±ØªÙŠ"], ""), group=277288870000127181882)
async def mgsslock(client, message):
   get = await client.get_chat_member(message.chat.id, message.from_user.id)
   if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID or message.from_user.id == 7728230165:
      if message.chat.id in mgssof:
        return await message.reply_text("ØµÙˆØ±ØªÙŠ Ù…Ø¹Ø·Ù„ Ù…Ù† Ù‚Ø¨Ù„")
      mgssof.append(message.chat.id)
      return await message.reply_text("ØªÙ… ØªØ¹Ø·ÙŠÙ„ ØµÙˆØ±ØªÙŠ Ø¨Ù†Ø¬Ø§Ø­")
   else:
      return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command(["ÙØªØ­ ØµÙˆØ±ØªÙŠ", "ØªÙØ¹ÙŠÙ„ ØµÙˆØ±ØªÙŠ"], ""), group=726262766000288)
async def mgssopen(client, message):
   get = await client.get_chat_member(message.chat.id, message.from_user.id)
   if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID or message.from_user.id == 7728230165:
      if not message.chat.id in mgssof:
        return await message.reply_text("ØµÙˆØ±ØªÙŠ Ù…ÙØ¹Ù„ Ù…Ù† Ù‚Ø¨Ù„\n")
      mgssof.remove(message.chat.id)
      return await message.reply_text("ØªÙ… ØªÙØ¹ÙŠÙ„ ØµÙˆØ±ØªÙŠ Ø¨Ù†Ø¬Ø§Ø­")
   else:
      return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
      

RAEAK = ["ÙØ§Ø¬Ø±Ù‡","Ø­Ù„ÙˆÙ‡","ÙØ®Ø§Ù…Ù‡","Ø¬Ù…ÙŠÙ„Ù‡","Ø®ÙˆØ´","Ø¬Ù…ÙŠÙ„Ù‡","ÙŠØ¹Ø¹Ø¹Ø¹Ø¹","ÙˆØ­Ø´Ù‡","Ù…Ø´ Ø­Ù„ÙˆÙ‡","Ø­Ù„ÙˆÙ‡ ÙŠØ§Ø¹Ù…","Ø®Ù„ÙŠÙƒ Ø¨ÙŠÙ‡Ø§","Ø­Ø¨ØªÙ‡Ø§","ØºÙŠØ±Ù‡Ø§ ÙŠØ¹Ù…"]




@app.on_message(filters.command(["ØµÙˆØ±ØªÙŠ"], ""), group=104)
async def mgssggg(client: Client, message: Message):
    if message.chat.id in mgssof:
      return await message.reply_text("ØµÙˆØ±ØªÙŠ Ù…Ø¹Ø·Ù„ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø¯Ù…Ù†")
      
    usr = await client.get_users(message.from_user.id)
    name = usr.first_name
    chat_id = message.chat.id
    user_id = message.from_user.id
    name = usr.first_name
    if usr.photo:
        photo = await app.download_media(usr.photo.big_file_id)

        await message.reply_photo(photo=photo,      caption=f"""<b> Ëšâ€§SHEIKHË³+\nâ•®â—‰ Ø§Ù†Ø§ ÙƒØ§ Ø¨ÙˆØª Ù‡Ù‚ÙˆÙ„\nâ”‚ášœâ—‰ Ø±Ø£ÙŠÙŠ ÙŠØ§ : {message.from_user.mention}\nâ•¯â—‰ ÙÙŠ ØµÙˆØ±ØªÙƒ:- ( {choice(RAEAK)} )</b>""", 
        reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        name, url=f"https://t.me/{message.from_user.username}")
                ],
            ]
        ),
    )
    else:
        await message.reply_text("Ù‡ÙŠÙŠÙ‡ Ù…Ø¹Ù†Ø¯Ùƒ ØµÙˆØ±Ù‡ ÙŠØ§Ø±ÙˆØ¹!")        



@app.on_message(filters.command(["ØµÙˆØ±ØªÙ‡"], ""), group=10476)
async def mgssgg6tg(client: Client, message: Message):
    if message.chat.id in mgssof:
      return await message.reply_text("ØµÙˆØ±ØªÙŠ Ù…Ø¹Ø·Ù„ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø¯Ù…Ù†")
      
    usr = await client.get_users(message.reply_to_message.from_user.id)
    name = usr.first_name
    chat_id = message.chat.id
    user_id = message.from_user.id
    name = usr.first_name
    if usr.photo:
        photo = await app.download_media(usr.photo.big_file_id)

        await message.reply_photo(photo=photo,      caption=f"""<b> Ëšâ€§SHEIKHË³+\nâ•®â—‰ Ø§Ù†Ø§ ÙƒØ§ Ø¨ÙˆØª Ù‡Ù‚ÙˆÙ„\nâ”‚ášœâ—‰ Ø±Ø£ÙŠÙŠ ÙŠØ§ : {message.from_user.mention}\nâ•¯â—‰ ÙÙŠ ØµÙˆØ±ØªÙ‡:- ( {choice(RAEAK)} )</b>""", 
        reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        name, url=f"https://t.me/{message.from_user.username}")
                ],
            ]
        ),
    )
    else:
        await message.reply_text("Ù‡ÙŠÙŠÙ‡ Ù…Ø¹Ù†Ø¯Ùƒ ØµÙˆØ±Ù‡ ÙŠØ§Ø±ÙˆØ¹!")        
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚


@app.on_message(filters.command(["Ø§Ù„Ù…Ø§Ù„Ùƒ", "ØµØ§Ø­Ø¨ Ø§Ù„Ø®Ø±Ø§Ø¨Ù‡", "Ø§Ù„Ù…Ù†Ø´ÙŠ"], ""), group=95)
async def ownner(client: Client, message: Message):
    x = []
   
    async for m in app.get_chat_members(message.chat.id, filter=enums.ChatMembersFilter.ADMINISTRATORS):
         if m.status == ChatMemberStatus.OWNER:
            x.append(m.user.id)
    if len(x) != 0:        
       m = await app.get_users(int(x[0]))
       if m.photo:
         async for photo in app.get_chat_photos(x[0],limit=1):
          await message.reply_photo(photo.file_id,caption=f"<blockquote><b>â•­â—‰ášÉ´á´§á´á´‡ : {m.first_name}\nâ”‚ášœâ—‰á´œsá´‡ê› : @{m.username}\nâ•°â—‰ášÉªá´… : <code>{m.id}</code>\nâ•­â—‰ášá´„Êœá´§á´› : {message.chat.title}\nâ•°â—‰ášÉªá´….á´„Êœá´§á´› : <code>{message.chat.id}</code></b></blockquote>",reply_markup=InlineKeyboardMarkup(
             [              
               [          
                 InlineKeyboardButton(m.first_name, url=f"https://t.me/{m.username}")
               ],             
             ]                 
            )                     
          )
       else:
        await message.reply_text(f"b><blockquote>â•­â—‰ášÉ´á´§á´á´‡ : {m.first_name}\nâ”‚ášœâ—‰á´œsá´‡ê› : @{m.username}\nâ•°â—‰ášÉªá´… : <code>{m.id}</code>\nâ•­â—‰ášá´„Êœá´§á´› : {message.chat.title}\nâ•°â—‰ášÉªá´….á´„Êœá´§á´› : <code>{message.chat.id}</code></b></blockquote>", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton(m.first_name, url=f"https://t.me/{m.username}")],]))
    else:
        await message.reply_text("Ø¹Ø²ÙŠØ²ÙŠ Ø§Ù„Ù…Ø§Ù„Ùƒ Ù‡Ø°Ø§ Ø­Ø³Ø§Ø¨ Ù…Ø­Ø°ÙˆÙ")



# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚



kashf = []
@app.on_message(filters.command(["Ù‚ÙÙ„ ÙƒØ´Ù", "ØªØ¹Ø·ÙŠÙ„ ÙƒØ´Ù"], ""), group=8888811223330099)
async def iddlock(client, message):
   get = await client.get_chat_member(message.chat.id, message.from_user.id)
   if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID or message.from_user.id == 7728230165:
      if message.chat.id in kashf:
        return await message.reply_text("Ø§Ù„ÙƒØ´Ù Ù…Ø¹Ø·Ù„ Ù…Ù† Ù‚Ø¨Ù„")
      kashf.append(message.chat.id)
      return await message.reply_text("ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ÙƒØ´Ù Ø¨Ù†Ø¬Ø§Ø­")
   else:
      return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command(["ÙØªØ­ ÙƒØ´Ù", "ØªÙØ¹ÙŠÙ„ ÙƒØ´Ù"], ""), group=70000000000000001111)
async def iddopen(client, message):
   get = await client.get_chat_member(message.chat.id, message.from_user.id)
   if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR]:
      if not message.chat.id in kashf:
        return await message.reply_text("Ø§Ù„ÙƒØ´Ù Ù…ÙØ¹Ù„ Ù…Ù† Ù‚Ø¨Ù„")
      kashf.remove(message.chat.id)
      return await message.reply_text("ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙƒØ´Ù Ø¨Ù†Ø¬Ø§Ø­")
   else:
      return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
   
from random import choice
from pyrogram import filters

# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚

                          
message_counts = {}


def update_message_count(group_id, user_id):
    key = (group_id, user_id)
    if key not in message_counts:
        message_counts[key] = 0
    message_counts[key] += 1


async def get_users(client, user_id):
    pass


@app.on_message(filters.group, group=555007655)
async def handle_message(client, message):
    group_id = message.chat.id
    user_id = message.from_user.id
    update_message_count(group_id, user_id)


user_messages = {}
@app.on_message(filters.regex("^Ø±Ø³Ø§ÙŠÙ„ÙŠ$") & filters.group, group=62839499)
async def delrdood(app, message):
    chat_id = str(message.chat.id)
    user_id = str(message.from_user.id)
    messages = user_messages.get(chat_id, {}).get(user_id, [])
    await message.reply(f"<blockquote>Â» Ø¹Ø¯Ø¯ Ø±Ø³Ø§Ø¦Ù„Ùƒ : {len(messages)}</blockquote>")

@app.on_message(filters.text & filters.group, group=15363729)
async def gettt_rd(app, message):
    chat_id = str(message.chat.id)
    user_id = str(message.from_user.id)
    if chat_id not in user_messages:
        user_messages[chat_id] = {}
    if user_id not in user_messages[chat_id]:
        user_messages[chat_id][user_id] = []
    user_messages[chat_id][user_id].append(message.text)    



@app.on_message(filters.regex("^Ø±Ø³Ø§ÙŠÙ„Ù‡$") & filters.group, group=6283949968)
async def delrdoyt(app, message):
    chat_id = str(message.chat.id)
    user_id = str(message.reply_to_message.from_user.id)
    messages = user_messages.get(chat_id, {}).get(user_id, [])
    await message.reply(f"Â» <blockquote>Ø¹Ø¯Ø¯ Ø±Ø³Ø§Ø¦Ù„Ù‡ : {len(messages)}</blockquote>")


# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚


async def get_user_status(user_id: int, message):
    user_id = message.reply_to_message.from_user.id
    chat_id = message.chat.id
    member = await app.get_chat_member(chat_id, user_id)
    rank = "Ø¹Ø¶Ùˆ Ø­Ù‚ÙŠØ±"
    
    if user_id == 7728230165:
        rank = "Ù…Ø·ÙˆØ± Ø¬Ø§Ùƒ"
    elif user_id == 7728230165:
        rank = "Ø¬Ø§Ùƒ"
    elif user_id == OWNER_ID:
        rank = "Ù…Ø·ÙˆØ± Ø§Ù„Ø¨ÙˆØª"
    elif member.status == ChatMemberStatus.OWNER:
        rank = "Ù…Ø§Ù„Ùƒ Ø§Ù„Ø§Ø³Ø§Ø³ÙŠ"
    elif member.status == ChatMemberStatus.ADMINISTRATOR:
        rank = "Ù…Ø´Ø±Ù"
    
    return rank


@app.on_message(filters.command(["ÙƒØ´Ù", "Ù…ÙŠÙ† Ø¯Ø§", "Ø§Ù„ÙƒØ´Ù"], ""), group=1024)
async def reveal_user_info(client, message):
   
    if message.chat.id in kashf:
        return await message.reply_text("The reveal feature is disabled by the admin")

    if not message.reply_to_message:
        return

    try:
        target_user = message.reply_to_message.from_user
        user_id = target_user.id
        chat = message.chat
        username = f"@{target_user.username}" if target_user.username else "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙŠÙˆØ²Ø±"
        profile_link = f"https://t.me/{target_user.username}" if target_user.username else f"tg://user?id={user_id}"
        
        user_info = await client.get_chat(user_id)
        bio = user_info.bio if user_info.bio else "No bio available"
        
        rank = await get_user_status(user_id, message)
        fan_count = len(id.get(user_id, [])) if 'id' in globals() else 0
        messages = user_messages.get(str(chat.id), {}).get(str(user_id), []) if 'user_messages' in globals() else []

        random_phrases = ["ØªØ¹Ø¨Ø§Ù†", "Ø¹Ù†Ø¯Ù‡ Ø¨Ø±Ø¯", "Ø³Ø®Ù†", "Ù‡Ø¨ÙˆØ·", "Ø¨ÙŠØªÙƒÙˆÙ‡Ù†", "Ø¨ÙŠØªØ¹Ù„Ù‚", "Ø¨ÙŠØªÙ…Ø­Ù†", "Ø¨ÙŠØ³ØªÙ‡Ø¨Ù„", "Ø¹ÙŠØ§Ù†", "ÙÙŠ Ø§Ù„Ù†Ø§Ø²Ù„"]
        random_phrase = choice(random_phrases)
        button = InlineKeyboardMarkup([[
            InlineKeyboardButton(
                text=target_user.first_name,
                url=profile_link
            )
        ]])

        caption = (
            f"<b><blockquote>â•­â—‰ášÉ´á´§á´á´‡ : {target_user.mention()}</b>\n"
            f"â”‚ášœâ—‰á´œsá´‡ê› : {username}\n"
            f"â•°â—‰ášÉªá´… : <code>{user_id}</code>\n"
            f"â•­â—‰ášÊœá´‡á´€ÊŸá´›Êœ : {random_phrase}\n"
            f"â”‚ášœâ—‰ÊŸÉªá´‹á´‡êœ± : {fan_count}\n"
            f"â”‚ášœâ—‰êœ±á´›á´€á´›á´œêœ± : {rank}\n"
            f"â”‚ášœâ—‰á´á´‡êœ±êœ±á´€É¢á´‡êœ± : {len(messages)}\n"
            f"â•°â—‰ášÊ™Éªá´ : {bio}\n"
            f"â•­â—‰ášá´„Êœá´§á´› : {chat.title}\n"
            f"â”‚ášœâ—‰á´œsá´‡ê› : @{chat.username if chat.username else 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'}\n"
            f"â•°â—‰ášá´„Êœá´§á´› Éªá´… : <code>{chat.id}</code></blockquote></b>"
        )

        if user_info.photo:
            photo = user_info.photo.big_file_id
            photo_path = await app.download_media(photo)
            await message.reply_photo(
                photo=photo_path,
                caption=caption,
                reply_markup=button
            )
        else:
            await message.reply_text(
                caption,
                reply_markup=button
            )

    except Exception as e:
        print(f"Error: {e}")
        await message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª")
        
        
        
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚


iddof = []
@app.on_message(filters.command(["Ù‚ÙÙ„ Ø¬Ù…Ø§Ù„ÙŠ", "ØªØ¹Ø·ÙŠÙ„ Ø¬Ù…Ø§Ù„ÙŠ"], ""), group=509)
async def iddlock(client, message):
   get = await client.get_chat_member(message.chat.id, message.from_user.id)
   if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID or message.from_user.id == 7728230165:
      if message.chat.id in iddof:
        return await message.reply_text(" Ø¬Ù…Ø§Ù„ÙŠ Ù…Ø¹Ø·Ù„ Ù…Ù† Ù‚Ø¨Ù„")
      iddof.append(message.chat.id)
      return await message.reply_text(" ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø¬Ù…Ø§Ù„ÙŠ Ø¨Ù†Ø¬Ø§Ø­")
   else:
      return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command(["ÙØªØ­ Ø¬Ù…Ø§Ù„ÙŠ", "ØªÙØ¹ÙŠÙ„ Ø¬Ù…Ø§Ù„ÙŠ"], ""), group=678)
async def iddopen(client, message):
   get = await client.get_chat_member(message.chat.id, message.from_user.id)
   if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID or message.from_user.id == 7728230165:
      if not message.chat.id in iddof:
        return await message.reply_text("Ø¬Ù…Ø§Ù„ÙŠ Ù…ÙØ¹Ù„ Ù…Ù† Ù‚Ø¨Ù„ ")
      iddof.remove(message.chat.id)
      return await message.reply_text("ØªÙ… ØªÙØ¹ÙŠÙ„  Ø¬Ù…Ø§Ù„ÙŠ Ø¨Ù†Ø¬Ø§Ø­")
   else:
      return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")


@app.on_message(filters.command(["Ø¬Ù…Ø§Ù„ÙŠ"], ""), group=104)
async def idjjdd(client, message):
    if message.chat.id in iddof:
      return await message.reply_text(" Ø¬Ù…Ø§Ù„ÙŠ Ù…Ø¹Ø·Ù„ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø¯Ù…Ù†")
    usr = await client.get_chat(message.from_user.id)
    name = usr.first_name
    i = ["1","10", "15","20", "25","30","35", "40","45", "50","55", "60"," 66", "70","77", "80","85", "90","99", "100","1000" ]
    ik = random.choice(i)
    if usr.photo:
        photo = await app.download_media(usr.photo.big_file_id)
        await message.reply_photo(photo,       caption=f"<b> Ëšâ€§SHEIKHË³+\nâ•®â—‰ Ù‡Ù„ Ø®Ù„Ù‚ Ø§Ù„Ø¬Ù…Ø§Ù„ Ù„ØªØ®ØªØµØ±Ù‡ Ø¹ÙŠÙ†Ø§Ùƒ Ø§Ù…Ø§\nâ”‚ášœâ—‰ Ø¹ÙŠÙ†Ø§Ùƒ Ø®Ù„Ù‚Øª Ù„ØªÙ‚Ù†Ø¹Ù†ÙŠ Ø§Ù† Ù„Ø§ Ø¬Ù…Ø§Ù„ Ø¨Ø¹Ø¯Ù‡Ø§\nâ•¯â—‰ Ø¬Ù…Ø§Ù„ Ø¹ÙŠÙ†Ø§Ùƒ ({ik}) % â¤ï¸</b>", 
    reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        name, url=f"https://t.me/{message.from_user.username}")
                ],
            ]
        ),
    )    
    else:
        await message.reply_text("Ù‡ÙŠÙŠÙ‡ Ù…Ø¹Ù†Ø¯Ùƒ ØµÙˆØ±Ù‡ ÙŠØ§Ø±ÙˆØ¹!!")               



@app.on_message(filters.command(["Ø¬Ù…Ø§Ù„Ù‡"], ""), group=106454)
async def idjjddhhff(client, message):
    if message.chat.id in iddof:
      return await message.reply_text(" Ø¬Ù…Ø§Ù„ÙŠ Ù…Ø¹Ø·Ù„ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø¯Ù…Ù†")
    usr = await client.get_chat(message.reply_to_message.from_user.id)
    name = usr.first_name
    i = ["1","10", "15","20", "25","30","35", "40","45", "50","55", "60"," 66", "70","77", "80","85", "90","99", "100","1000" ]
    ik = random.choice(i)
    if usr.photo:
        photo = await app.download_media(usr.photo.big_file_id)
        await message.reply_photo(photo,       caption=f"<b> Ëšâ€§SHEIKHË³+\nâ•®â—‰ Ù‡Ù„ Ø®Ù„Ù‚ Ø§Ù„Ø¬Ù…Ø§Ù„ Ù„ØªØ®ØªØµØ±Ù‡ Ø¹ÙŠÙ†Ø§Ùƒ Ø§Ù…Ø§\nâ”‚ášœâ—‰ Ø¹ÙŠÙ†Ø§Ùƒ Ø®Ù„Ù‚Øª Ù„ØªÙ‚Ù†Ø¹Ù†ÙŠ Ø§Ù† Ù„Ø§ Ø¬Ù…Ø§Ù„ Ø¨Ø¹Ø¯Ù‡Ø§\nâ•¯â—‰ Ø¬Ù…Ø§Ù„ Ø§Ù„Ø§Ø±Ù†Ø¨ ({ik}) % â¤ï¸</b>", 
    reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        name, url=f"https://t.me/{message.from_user.username}")
                ],
            ]
        ),
    )    
    else:
        await message.reply_text("Ù‡ÙŠÙŠÙ‡ Ù…Ø¹Ù†Ø¯Ùƒ ØµÙˆØ±Ù‡ ÙŠØ§Ø±ÙˆØ¹!!")          

# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚


tarof = []

@app.on_message(filters.command(["ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªØ±Ø­ÙŠØ¨","Ù‚ÙÙ„ Ø§Ù„ØªØ±Ø­ÙŠØ¨"], ""), group=888888888888888811234)
async def disable_welcome(client, message):
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID or message.from_user.id == 7728230165 or message.from_user.id == 7728230165:
        if message.chat.id in tarof:
            return await message.reply_text("Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ù…Ø¹Ø·Ù„ Ù…Ù† Ù‚Ø¨Ù„")
        tarof.append(message.chat.id)
        return await message.reply_text("ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø¨Ù†Ø¬Ø§Ø­")
    else:
        return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³Ø±")

@app.on_message(filters.command(["ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ±Ø­ÙŠØ¨","ÙØªØ­ Ø§Ù„ØªØ±Ø­ÙŠØ¨"], ""), group=6666666666123090000011)
async def enable_welcome(client, message):
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID or message.from_user.id == 7728230165 or message.from_user.id == 7728230165:
        if message.chat.id not in tarof:
            return await message.reply_text("Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ù…ÙØ¹Ù„ Ù…Ù† Ù‚Ø¨Ù„")
        tarof.remove(message.chat.id)
        return await message.reply_text("ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø¨Ù†Ø¬Ø§Ø­")
    else:
        return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")





@app.on_message(filters.new_chat_members, group=554)
async def welcometo_members(client, message):
    if message.chat.id in tarof:
        return await message.reply_text("Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ù…Ø¹Ø·Ù„ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø¯Ù…Ù†")
    
    current_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    for user in message.new_chat_members:
        try:
            if user.is_bot:
                continue
                
            chat_id = message.chat.id
            username = user.username if user.username else "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¹Ø±Ù"
            mention = user.mention
            
            keyboard = []
            if user.username:
                keyboard = [
                    [InlineKeyboardButton(
                        user.first_name, url=f"https://t.me/{user.username}")
                    ]
                ]
            
            welcome_text = (
                f"<blockquote>Ù„Ø§ ØªÙØ³ÙØ¦ Ø§Ù„Ù„ÙØ¸ ÙˆØ¥Ù† Ø¶ÙØ§Ù‚ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø±ÙÙ‘Ø¯\n"
                f"É´á´§á´á´‡ âŒ¯ {mention}\n"
                f"á´œÑ•á´‡ê›É´á´§á´á´‡ âŒ¯ @{username}\n"
                f"á´…á´€á´›á´‡ âŒ¯ {current_date}</blockquote>"
            )
            
            await app.send_message(
                chat_id=chat_id,
                text=welcome_text,
                reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None
            )
            
        except Exception as e:
            print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ±Ø­ÙŠØ¨: {str(e)}")

@app.on_message(filters.left_chat_member, group=222307)
async def onn_left_chat_member(_, message: Message):
    try:
        if message.chat.id in tarof:
            return
            
        current_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        user = message.left_chat_member
        
        if user.is_bot:
            return
            
        username = user.username if user.username else "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¹Ø±Ù"
        mention = user.mention
        
        chat_id = message.chat.id
        leave_text = (
            f"<blockquote>ÙˆÙØ£ÙÙ† Ù„ÙÙ‘ÙŠÙ’Ø³Ù Ù„ÙÙ„Ù’Ø¥ÙÙ†Ø³ÙØ§Ù†Ù Ø¥ÙÙ„ÙÙ‘Ø§ Ù…ÙØ§ Ø³ÙØ¹ÙÙ‰Ù°\n"
            f"É´á´§á´á´‡ âŒ¯ {mention}\n"
            f"á´œÑ•á´‡ê›É´á´§á´á´‡ âŒ¯ @{username}\n"
            f"á´…á´€á´›á´‡ âŒ¯ {current_date}</blockquote>"
        )
        
        await app.send_message(chat_id=chat_id, text=leave_text)
        
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„Ø¹Ø¶Ùˆ: {str(e)}")

# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
# â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚


@app.on_message(filters.command(["Ø§Ø³Ù…ÙŠ"], ""), group=6658)
async def vgdg(client: Client, message: Message):
    usr = await client.get_chat(message.from_user.id)
    name = usr.first_name
    await message.reply_text(
        f"""<blockquote><b> Ø¹Ø§Ø§Ø´Øª Ø§Ù„Ø§Ø³Ø§Ù…ÙŠ<b> Â»Â» <code>{message.from_user.mention}</code></blockquote>""",
    reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        message.from_user.first_name, url=f"https://t.me/{message.from_user.username}")
                ],
            ]
        )
    )


@app.on_message(filters.command(["Ø§Ø³Ù…Ù‡","Ø§Ø³Ù…Ùƒ"], ""), group=667558)
async def names4(client: Client, message: Message):
    usr = await client.get_chat(message.reply_to_message.from_user.id)
    name = usr.first_name
    await message.reply_text(
        f"""<blockquote><b> Ø§Ø³Ù… Ø§Ù„Ø§Ø±Ù†Ø¨<b> Â»Â» <code>{message.from_user.mention}</code></blockquote>""",
    reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        message.from_user.first_name, url=f"https://t.me/{message.from_user.username}")
                ],
            ]
        )
    )


